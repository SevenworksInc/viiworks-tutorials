<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Git Tutorials</title>

    <link href="assets/css/bootstrap.css" rel="stylesheet"><!-- Bootstrap Core CSS --><!-- Custom CSS -->
    <link href="assets/font-awesome-4.5.0/css/font-awesome.min.css" rel="stylesheet"><!-- Font Awesome CSS -->
    <link href="assets/css/custom.css" rel="stylesheet"><!-- Custom CSS -->
	
	
	<link rel="icon" type="image/x-icon" href="https://assets-cdn.github.com/favicon.ico">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body data-spy="scroll" data-target=".scrollspy" data-offset="80">
    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-custom navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="#">Git Workflow</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="#">Viiworks</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>
	<header class="header-image">
        <div class="headline">
            <div class="container">
                <h1><i class="fa fa-github"></i> Git</h1>
            </div>
        </div>
    </header>

    <!-- Page Content -->
    <div class="container">

        <div class="row">

            <div class="col-md-3 scrollspy" id="sidebar_affix">
				<ul class="nav nav-pills nav-stacked" data-spy="affix">
					<li role="presentation" class="active">
						<a href="#introduction">Introduction</a>
						<ul class="nav nav-sub">
							<li><a href="#wvc">What is a version Control</a></li>
							<li><a href="#bvc">Benefits of version Control</a></li>
							<li><a href="#wig">What is Git</a></li>
							<li><a href="#prf">Performance</a></li>
							<li><a href="#scy">Security</a></li>
							<li><a href="#flex">Flexibility</a></li>
							<li><a href="#vcg">Version Control with Git</a></li>
						</ul>
					</li>
					<li role="presentation"><a href="#basiccommands">Git Commands</a>
						<!-- https://www.thomas-krenn.com/en/wiki/Git_Basic_Commands -->
						<ul class="nav nav-sub">
							<li><a href="#crtrepo">Creating Repositories</a></li>
							<li><a href="#confgit">Configuring Git</a></li>
							<li><a href="#adngfls">Add</a></li>
							<li><a href="#rmtgfls">Remoting</a></li>
							<li><a href="#ftchfls">Fetching</a></li>
							<li><a href="#plngfls">Pulling</a></li>
							<li><a href="#phngfls">Pushing</a></li>
							<li><a href="#cmmtfls">Committing</a></li>
							<li><a href="#rbasfls">Rebase</a></li>
							<li><a href="#chkoutf">Checkout</a></li>
							<li><a href="#brncfls">Branching</a></li>
							<li><a href="#mergfls">Merging</a></li>
							<li><a href="#restfls">Reset</a></li>
							<li><a href="#clenfls">Clean</a></li>
							<li><a href="#difffls">Difference</a></li>
							<li><a href="#status">Status</a></li>
							<li><a href="#logsfls">Logs</a></li>
							<li><a href="#rvrtfls">Revert</a></li>
						</ul>
					</li>
					<li role="presentation"><a href="javascript:;">Team Workflow</a>
						<ul class="nav nav-sub">
							<li><a href="javscript:;">Fork Repository</a></li>
							<li><a href="javscript:;">Share Updates</a></li>
							<li><a href="javscript:;">Pull Requests</a></li>
						</ul>
					</li>
					<li role="presentation"><a href="javascript:;">Jackmedia</a>
						<ul class="nav nav-sub">
							<li><a href="javscript:;">Updates</a></li>
							<li><a href="javscript:;">Deployment using Jenkins</a></li>
						</ul>
					</li>
				</ul>
            </div>

            <div class="col-md-9 pull-right tutorial-content">
				<!-- <img src="img/svg/Git-Logo-1788C.svg" class="img-responsive img-cntr" /> -->
				<section id="introduction">
					<h1 class="tutorial-heading">Introduction</h1>
					
					<section id="wvc">
						<h2>What is a version Control?</h2>
						<p>Version control systems are a category of software tools that help a software team manage changes to source code over time. Version control software keeps track of every modification to the code in a special kind of database. If a mistake is made, developers can turn back the clock and compare earlier versions of the code to help fix the mistake while minimizing disruption to all team members.</p>

						<p>For almost all software projects, the source code is like the crown jewels - a precious asset whose value must be protected. For most software teams, the source code is a repository of the invaluable knowledge and understanding about the problem domain that the developers have collected and refined through careful effort. Version control protects source code from both catastrophe and the casual degradation of human error and unintended consequences.</p>

						<p>Software developers working in teams are continually writing new source code and changing existing source code. The code for a project, app or software component is typically organized in a folder structure or “file tree”. One developer on the team may be working on a new feature while another developer fixes an unrelated bug by changing code, each developer may make their changes in several parts of the file tree.</p>

						<p>Version control helps teams solve these kinds of problems, tracking every individual change by each contributor and helping prevent concurrent work from conflicting. Changes made in one part of the software can be incompatible with those made by another developer working at the same time. This problem should be discovered and solved in an orderly manner without blocking the work of the rest of the team. Further, in all software development, any change can introduce new bugs on its own and new software can‘t be trusted until it’s tested. So testing and development proceed together until a new version is ready.</p>

						<p>Good version control software supports a developer's preferred workflow without imposing one particular way of working. Ideally it also works on any platform, rather than dictate what operating system or tool chain developers must use. Great version control systems facilitate a smooth and continuous flow of changes to the code rather than the frustrating and clumsy mechanism of file locking - giving the green light to one developer at the expense of blocking the progress of others.</p>

						<p>Software teams that do not use any form of version control often run into problems like not knowing which changes that have been made are available to users or the creation of incompatible changes between two unrelated pieces of work that must then be painstakingly untangled and reworked. If you‘re a developer who has never used version control you may have added versions to your files, perhaps with suffixes like “final” or “latest” and then had to later deal with a new final version. Perhaps you’ve commented out code blocks because you want to disable certain functionality without deleting the code, fearing that there may be a use for it later. </p>Version control is a way out of these problems.

						<p>Version control software is an essential part of the every-day of the modern software team‘s professional practices. Individual software developers who are accustomed to working with a capable version control system in their teams typically recognize the incredible value version control also gives them even on small solo projects. Once accustomed to the powerful benefits of version control systems, many developers wouldn’t consider working without it even for non-software projects.</p>
					</section>
					<section id="bvc">
						<h2>Benefits of version control?</h2>
						<p>Developing software without using version control is risky, like not having backups. Version control can also enable developers to move faster and it allows software teams to preserve efficiency and agility as the team scales to include more developers.</p>

						<p>Version Control Systems (VCS) have seen great improvements over the past few decades and some are better than others. VCS are sometimes known as SCM (Source Code Management) tools or RCS (Revision Control System). One of the most popular VCS tools in use today is called Git. Git is a Distributed VCS, a category known as DVCS, more on that later. Like many of the most popular VCS systems available today, Git is free and open source. Regardless of what they are called, or which system is used, the primary benefits you should expect from version control are as follows.</p>
						
						<ol>
							<li>A complete long-term change history of every file. This means every change made by many individuals over the years. Changes include the creation and deletion of files as well as edits to their contents. Different VCS tools differ on how well they handle renaming and moving of files. This history should also include the author, date and written notes on the purpose of each change. Having the complete history enables going back to previous versions to help in root cause analysis for bugs and it is crucial when needing to fix problems in older versions of software. If the software is being actively worked on, almost everything can be considered an “older version” of the software.</li>
							<li>Branching and merging. Having team members work concurrently is a no-brainer, but even individuals working on their own can benefit from the ability to work on independent streams of changes. Creating a “branch” in VCS tools keeps multiple streams of work independent from each other while also providing the facility to merge that work back together, enabling developers to verify that the changes on each branch do not conflict. Many software teams adopt a practice of branching for each feature or perhaps branching for each release, or both. There are many different workflows that teams can choose from when they decide how to make use of branching and merging facilities in VCS.</li>
							<li>Traceability. Being able to trace each change made to the software and connect it to project management and bug tracking software such as JIRA, and being able to annotate each change with a message describing the purpose and intent of the change can help not only with root cause analysis and other forensics. Having the annotated history of the code at your fingertips when you are reading the code, trying to understand what it is doing and why it is so designed can enable developers to make correct and harmonious changes that are in accord with the intended long-term design of the system. This can be especially important for working effectively with legacy code and is crucial in enabling developers to estimate future work with any accuracy.</li>
						</ol>
						
						<p>While it is possible to develop software without using any version control, doing so subjects the project to a huge risk that no professional team would be advised to accept. So the question is not whether to use version control but which version control system to use.</p>

						<p>There are many choices, but here we are going to focus on just one, Git.</p>
					</section>
					<section id="wig">
						<h2>What is Git?</h2>
						<p>By far, the most widely used modern version control system in the world today is Git. Git is a mature, actively maintained open source project originally developed in 2005 by Linus Torvalds, the famous creator of the Linux operating system kernel. A staggering number of software projects rely on Git for version control, including commercial projects as well as open source. Developers who have worked with Git are well represented in the pool of available software development talent and it works well on a wide range of operating systems and IDEs (Integrated Development Environments).</p>

						<p>Having a distributed architecture, Git is an example of a DVCS (hence Distributed Version Control System). Rather than have only one single place for the full version history of the software as is common in once-popular version control systems like CVS or Subversion (also known as SVN), in Git, every developer's working copy of the code is also a repository that can contain the full history of all changes.</p>

						<p>In addition to being distributed, Git has been designed with performance, security and flexibility in mind.</p>
					</section>
					<section id="prf">
						<h2>Performance</h2>

						<p>The raw performance characteristics of Git are very strong when compared to many alternatives. Committing new changes, branching, merging and comparing past versions are all optimized for performance. The algorithms implemented inside Git take advantage of deep knowledge about common attributes of real source code file trees, how they are usually modified over time and what the access patterns are.</p>

						<p>Unlike some version control software, Git is not fooled by the names of the files when determining what the storage and version history of the file tree should be, instead, Git focuses on the file content itself. After all, source code files are frequently renamed, split, and rearranged. The object format of Git's repository files uses a combination of delta encoding (storing content differences), compression and explicitly stores directory contents and version metadata objects.</p>

						<p>Being distributed enables significant performance benefits as well.</p>

						<p>For example, say a developer, Alice, makes changes to source code, adding a feature for the upcoming 2.0 release, then commits those changes with descriptive messages. She then works on a second feature and commits those changes too. Naturally these are stored as separate pieces of work in the version history. Alice then switches to the version 1.3 branch of the same software to fix a bug that affects only that older version. The purpose of this is to enable Alice's team to ship a bug fix release, version 1.3.1, before version 2.0 is ready. Alice can then return to the 2.0 branch to continue working on new features for 2.0 and all of this can occur without any network access and is therefore fast and reliable. She could even do it on an airplane. When she is ready to send all of the individually committed changes to the remote repository, Alice can “push” them in one command.</p>
					</section>
					<section id="scy">
						<h2>Security</h2>

						<p>Git has been designed with the integrity of managed source code as a top priority. The content of the files as well as the true relationships between files and directories, versions, tags and commits, all of these objects in the Git repository are secured with a cryptographically secure hashing algorithm called SHA1. This protects the code and the change history against both accidental and malicious change and ensures that the history is fully traceable.</p>

						<p>With Git, you can be sure you have an authentic content history of your source code.</p>

						<p>Some other version control systems have no protections against secret alteration at a later date. This can be a serious information security vulnerability for any organization that relies on software development.</p>
					</section>
					<section id="flex">
						<h2>Flexibility</h2>

						<p>One of Git's key design objectives is flexibility. Git is flexible in several respects: in support for various kinds of nonlinear development workflows, in its efficiency in both small and large projects and in its compatibility with many existing systems and protocols.</p>

						<p>Git has been designed to support branching and tagging as first-class citizens (unlike SVN) and operations that affect branches and tags (such as merging or reverting) are also stored as part of the change history. Not all version control systems feature this level of tracking.</p>
					</section>
					<section id="vcg">
						<h2>Version control with Git</h2>

						<p>Git is the best choice for most software teams today. While every team is different and should do their own analysis, here are the main reasons why version control with Git is preferred over alternatives:</p>

						<h4>Git is good</h4>
						<p>Git has the functionality, performance, security and flexibility that most teams and individual developers need. These attributes of Git are detailed above. In side-by-side comparisons with most other alternatives, many teams find that Git is very favorable.</p>

						<h4>Git is a de facto standard</h4>
						<p>Git is the most broadly adopted tool of its kind. This is makes Git attractive for the following reasons. At Atlassian, nearly all of our project source code is managed in Git.</p>

						<p>Vast numbers of developers already have Git experience and a significant proportion of college graduates may have experience with only Git. While some organizations may need to climb the learning curve when migrating to Git from another version control system, many of their existing and future developers do not need to be trained on Git.</p>

						<p>In addition to the benefits of a large talent pool, the predominance of Git also means that many third party software tools and services are already integrated with Git including IDEs, and our own tools like DVCS desktop client SourceTree, issue and project tracking software, JIRA, and code hosting service, Bitbucket.</p>

						<p>If you are an inexperienced developer wanting to build up valuable skills in software development tools, when it comes to version control, Git should be on your list.</p>

						<h4>Git is a quality open source project</h4>
						<p>Git is a very well supported open source project with over a decade of solid stewardship. The project maintainers have shown balanced judgment and a mature approach to meeting the long term needs of its users with regular releases that improve usability and functionality. The quality of the open source software is easily scrutinized and countless businesses rely heavily on that quality.</p>

						<p>Git enjoys great community support and a vast user base. Documentation is excellent and plentiful, including books, tutorials and dedicated web sites. There are also podcasts and video tutorials.</p>

						<p>Being open source lowers the cost for hobbyist developers as they can use Git without paying a fee. For use in open-source projects, Git is undoubtedly the successor to the previous generations of successful open source version control systems, SVN and CVS.</p>

						<h4>Criticism of Git</h4>
						<p>One common criticism of Git is that it can be difficult to learn. Some of the terminology in Git will be novel to newcomers and for users of other systems, the Git terminology may be different, for example, revert in Git has a different meaning than in SVN or CVS. Nevertheless, Git is very capable and provides a lot of power to its users. Learning to use that power can take some time, however once it has been learned, that power can be used by the team to increase their development speed.</p>

						<p>For those teams coming from a non-distributed VCS, having a central repository may seem like a good thing that they don‘t want to lose. However, while Git has been designed as a distributed version control system (DVCS), with Git, you can still have an official, canonical repository where all changes to the software must be stored. With Git, because each developer’s repository is complete, their work doesn‘t need to be constrained by the availability and performance of the “central” server. During outages or while offline, developers can still consult the full project history. Because Git is flexible as well as being distributed, you can work the way you are accustomed to but gain the additional benefits of Git, some of which you may not even realise you’re missing.</p>

						<p>Now that you understand what version control is, what Git is and why software teams should use it, read on to discover the benefits Git can provide across the whole organization.</p>
					</section>
				</section>
				
				<section id="basiccommands">
					
					<h1>Basic Git Commands</h1>
					<section id="crtrepo">
						<h2>Setting up a repository</h2>
						<h4>git init</h4>
						<p>The <span class="command-line">git init</span> command creates a new Git repository. It can be used to convert an existing, unversioned project to a Git repository or initialize a new empty repository. Most of the other Git commands are not available outside of an initialized repository, so this is usually the first command you’ll run in a new project.</p>

						<p>Executing <span class="command-line">git init</span>  creates a <span class="command-line">.git</span> subdirectory in the project root, which contains all of the necessary metadata for the repo. Aside from the <span class="command-line">.git</span> directory, an existing project remains unaltered (unlike SVN, Git doesn't require a <span class="command-line">.git</span> folder in every subdirectory).</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git init</span>
							</div>
						</div>
						<p>Transform the current directory into a Git repository. This adds a <span class="command-line">.git</span>  folder to the current directory and makes it possible to start recording revisions of the project.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git init &lt;directory&gt;</span>
							</div>
						</div>
						<p>Create an empty Git repository in the specified directory. Running this command will create a new folder called &lt;directory&gt; containing nothing but the <span class="command-line">.git</span> subdirectory.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git init --bare &lt;directory&gt;</span>
							</div>
						</div>
						<p>Initialize an empty Git repository, but omit the working directory. Shared repositories should always be created with the <span class="command-line">--bare</span> flag (see discussion below). Conventionally, repositories initialized with the <span class="command-line">--bare</span> flag end in <span class="command-line">.git</span>. For example, the bare version of a repository called <span class="command-line">my-project</span> should be stored in a directory called <span class="command-line">my-project.git</span>.</p>
					</section>
					
					<section id="confgit">
						<h2>git config</h2>
						<p>The git config command lets you configure your Git installation (or an individual repository) from the command line. This command can define everything from user info to preferences to the behavior of a repository. Several common configuration options are listed below.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git config user.name &lt;name&gt;</span>
							</div>
						</div>
						<p>Define the author name to be used for all commits in the current repository. Typically, you’ll want to use the --global flag to set configuration options for the current user.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git config --global user.name &lt;name&gt;</span>
							</div>
						</div>
						<p>Define the author name to be used for all commits by the current user.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git config --global user.email &lt;email&gt;</span>
							</div>
						</div>
						<p>Define the author email to be used for all commits by the current user.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git config --global alias &lt;alias-name&gt; &lt;git-command&gt;</span>
							</div>
						</div>
						<p>Create a shortcut for a Git command.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git config --system core.editor &lt;editor&gt;</span>
							</div>
						</div>
						<p>Define the text editor used by commands like git commit for all users on the current machine. The &lt;editor&gt; argument should be the command that launches the desired editor (e.g., vi).</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git config --system --edit</span>
							</div>
						</div>
						<p>Open the global configuration file in a text editor for manual editing.</p>
						
						<h4>Example</h4>
						<p>The first thing you’ll want to do after installing Git is tell it your name/email and customize some of the default settings. A typical initial configuration might look something like the following:</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; # Tell Git who you are</span><br/>
							<span class="code-sample">&#36; git config --global user.name "John Smith"</span><br/>
							<span class="code-sample">&#36; git config --global user.email john@example.com</span>
							</div>
						</div>
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; # Select your favorite text editor</span><br/>
							<span class="code-sample">&#36; git config --global core.editor vim</span>
							</div>
						</div>
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; # Add some SVN-like aliases</span><br/>
							<span class="code-sample">&#36; git config --global alias.st status</span><br/>
							<span class="code-sample">&#36; git config --global alias.co checkout</span><br/>
							<span class="code-sample">&#36; git config --global alias.br branch</span><br/>
							<span class="code-sample">&#36; git config --global alias.up rebase</span><br/>
							<span class="code-sample">&#36; git config --global alias.ci commit</span>
							</div>
						</div>
					</section>
					
					<section id="adngfls">
						<h2>git add</h2>
						<p>The <span class="command-line">git add</span> command adds a change in the working directory to the staging area. It tells Git that you want to include updates to a particular file in the next commit. However, <span class="command-line">git add</span> doesn't really affect the repository in any significant way—changes are not actually recorded until you run <a href="#cmmtfls"><span class="command-line">git commit</span></a>.</p>
						<p>In conjunction with these commands, you'll also need <a href="#cmmtfls"><span class="command-line">git status</span></a> to view the state of the working directory and the staging area.</p>
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git add &lt;file&gt;</span>
							</div>
						</div>
						<p>Stage all changes in <span class="command-line">&lt;file&gt;</span> for the next commit</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git add &lt;directory&gt;</span>
							</div>
						</div>
						<p>Stage all changes in <span class="command-line">&lt;directory&gt;</span> for the next commit</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git add &#45;p</span>
							</div>
						</div>
						<p>Begin an interactive staging session that lets you choose portions of a file to add to the next commit. This will present you with a chunk of changes and prompt you for a command. Use <span class="code-sample">y</span> to stage the chunk, <span class="code-sample">n</span> to ignore the chunk, <span class="code-sample">s</span> to split it into smaller chunks, <span class="code-sample">e</span> to manually edit the chunk, and <span class="code-sample">q</span> to exit.</p>
						
						<h4>Discussion</h4>
						<p>The <span class="code-sample">git add</span> and <span class="code-sample">git commit</span> commands compose the fundamental Git workflow. These are the two commands that every Git user needs to understand, regardless of their team’s collaboration model. They are the means to record versions of a project into the repository’s history.</p>

						<p>Developing a project revolves around the basic edit/stage/commit pattern. First, you edit your files in the working directory. When you’re ready to save a copy of the current state of the project, you stage changes with <span class="code-sample">git add</span>. After you’re happy with the staged snapshot, you commit it to the project history with <span class="code-sample">git commit</span>.</p>
						
						<p>The <span class="code-sample">git add</span> command should not be confused with <span class="code-sample">svn add</span>, which adds a file to the repository. Instead, git add works on the more abstract level of changes. This means that <span class="code-sample">git add</span> needs to be called every time you alter a file, whereas <span class="code-sample">svn add</span> only needs to be called once for each file. It may sound redundant, but this workflow makes it much easier to keep a project organized.</p>

						<h4>The Staging Area</h4>
						<p>The staging area is one of Git's more unique features, and it can take some time to wrap your head around it if you’re coming from an SVN (or even a Mercurial) background. It helps to think of it as a buffer between the working directory and the project history.</p>

						<p>Instead of committing all of the changes you've made since the last commit, the stage lets you group related changes into highly focused snapshots before actually committing it to the project history. This means you can make all sorts of edits to unrelated files, then go back and split them up into logical commits by adding related changes to the stage and commit them piece-by-piece. As in any revision control system, it’s important to create atomic commits so that it’s easy to track down bugs and revert changes with minimal impact on the rest of the project.</p>
						
						<h4>Example</h4>
						<p>When you’re starting a new project, git add serves the same function as svn import. To create an initial commit of the current directory, use the following two commands:</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git add &#46;</span><br/>
							<span class="code-sample">&#36; git commit</span>
							</div>
						</div>
						<p>Once you’ve got your project up-and-running, new files can be added by passing the path to <span class="code-sample">git add</span>:</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git add hello&#46;py</span><br/>
							<span class="code-sample">&#36; git commit</span>
							</div>
						</div>
						<p>The above commands can also be used to record changes to existing files. Again, Git doesn’t differentiate between staging changes in new files vs. changes in files that have already been added to the repository.</p>
					</section>
					<section id="rmtgfls">
						<h2>git remote</h2>
						<p>The git remote command lets you create, view, and delete connections to other repositories. Remote connections are more like bookmarks rather than direct links into other repositories. Instead of providing real-time access to another repository, they serve as convenient names that can be used to reference a not-so-convenient URL.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git remote</span>
							</div>
						</div>
						<p>List the remote connections you have to other repositories.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git remote -v</span>
							</div>
						</div>
						<p>Same as the above command, but include the URL of each connection.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git remote add &lt;name&gt; &lt;url&gt;</span>
							</div>
						</div>
						<p>Create a new connection to a remote repository. After adding a remote, you’ll be able to use &lt;name&gt; as a convenient shortcut for &lt;url&gt; in other Git commands.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git remote rm &lt;name&gt;</span>
							</div>
						</div>
						<p>Remove the connection to the remote repository called &lt;name&gt;.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git remote rename &lt;old-name&gt; &lt;new-name&gt;</span>
							</div>
						</div>
						<p>Rename a remote connection from &lt;old-name&gt; to &lt;new-name&gt;.</p>
					</section>
					<section id="ftchfls">
						<h2>git fetch</h2>
						<p>The git fetch command imports commits from a remote repository into your local repo. The resulting commits are stored as remote branches instead of the normal local branches that we’ve been working with. This gives you a chance to review changes before integrating them into your copy of the project.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git fetch &lt;remote&gt;</span>
							</div>
						</div>
						<p>Fetch all of the branches from the repository. This also downloads all of the required commits and files from the other repository.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git fetch &lt;remote&gt; &lt;branch&gt;</span>
							</div>
						</div>
						<p>Same as the above command, but only fetch the specified branch.</p>
					</section>
					<section id="plngfls">
						<h2>git pull</h2>
						<p>Merging upstream changes into your local repository is a common task in Git-based collaboration workflows. We already know how to do this with git fetch followed by git merge, but git pull rolls this into a single command.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git pull &lt;remote&gt;</span>
							</div>
						</div>
						<p>Fetch the specified remote’s copy of the current branch and immediately merge it into the local copy. This is the same as <br>git fetch &lt;remote&gt; followed by <br>git merge origin/&lt;current-branch&gt;.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git pull --rebase &lt;remote&gt;</span>
							</div>
						</div>
						<p>Same as the above command, but instead of using git merge to integrate the remote branch with the local one, use git rebase.</p>
					</section>
					<section id="phngfls">
						<h2>git push</h2>
						<p>Pushing is how you transfer commits from your local repository to a remote repo. It's the counterpart to git fetch, but whereas fetching imports commits to local branches, pushing exports commits to remote branches. This has the potential to overwrite changes, so you need to be careful how you use it. These issues are discussed below.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git push &lt;remote&gt;</span>
							</div>
						</div>
						<p>Push the specified branch to &lt;remote&gt;, along with all of the necessary commits and internal objects. This creates a local branch in the destination repository. To prevent you from overwriting commits, Git won’t let you push when it results in a non-fast-forward merge in the destination repository.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git push &lt;remote&gt; --force</span>
							</div>
						</div>
						<p>Same as the above command, but force the push even if it results in a non-fast-forward merge. Do not use the --force flag unless you’re absolutely sure you know what you’re doing.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git push &lt;remote&gt; --all</span>
							</div>
						</div>
						<p>Push all of your local branches to the specified remote.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git push &lt;remote&gt; --tags</span>
							</div>
						</div>
						<p>Tags are not automatically pushed when you push a branch or use the --all option. The --tags flag sends all of your local tags to the remote repository.</p>
					</section>
					<section id="cmmtfls">
						<h2>git commit</h2>
						<p>The git commit command commits the staged snapshot to the project history. Committed snapshots can be thought of as “safe” versions of a project—Git will never change them unless you explicity ask it to. Along with <span class="code-sample">git add</span>, this is one of the most important Git commands.</p>

						<p>While they share the same name, this command is nothing like svn commit. Snapshots are committed to the local repository, and this requires absolutely no interaction with other Git repositories.</p>
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git commit</span>
							</div>
						</div>
						<p>Commit the staged snapshot. This will launch a text editor prompting you for a commit message. After you’ve entered a message, save the file and close the editor to create the actual commit. <span class="code-sample">git commit -m &quot;&lt;message&gt;&quot;</span></p>

						<p>Commit the staged snapshot, but instead of launching a text editor, use &lt;message&gt; as the commit message.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git commit &#45;a</span>
							</div>
						</div>
						<p>Commit a snapshot of all changes in the working directory. This only includes modifications to tracked files (those that have been added with git add at some point in their history).</p>
					</section>
					<section id="rbasfls">
						<h2>git rebase</h2>
						<p>Rebasing is the process of moving a branch to a new base commit.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git rebase &lt;base&gt;</span>
							</div>
						</div>
						<p>Rebase the current branch onto &lt;base&gt;, which can be any kind of commit reference (an ID, a branch name, a tag, or a relative reference to HEAD).</p>
					</section>
					<section id="chkoutf">
						<h2>git checkout</h2>
						<p>The git checkout command serves three distinct functions: checking out files, checking out commits, and checking out branches. In this module, we’re only concerned with the first two configurations.</p>

						<p>Checking out a commit makes the entire working directory match that commit. This can be used to view an old state of your project without altering your current state in any way. Checking out a file lets you see an old version of that particular file, leaving the rest of your working directory untouched.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git checkout master status</span>
							</div>
						</div>
						<p>Return to the master branch. Branches are covered in depth in the next module, but for now, you can just think of this as a way to get back to the “current” state of the project.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git checkout &lt;commit&gt; &lt;file&gt;</span>
							</div>
						</div>
						<p>Check out a previous version of a file. This turns the &lt;file&gt; that resides in the working directory into an exact copy of the one from &lt;commit&gt; and adds it to the staging area.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git checkout &lt;commit&gt;</span>
							</div>
						</div>
						<p>Update all files in the working directory to match the specified commit. You can use either a commit hash or a tag as the &lt;commit&gt; argument. This will put you in a detached HEAD state.</p>
					</section>
					<section id="brncfls">
						<h2>git branch</h2>
						<p>A branch represents an independent line of development. Branches serve as an abstraction for the edit/stage/commit process discussed in Git Basics, the first module of this series. You can think of them as a way to request a brand new working directory, staging area, and project history. New commits are recorded in the history for the current branch, which results in a fork in the history of the project.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git branch</span>
							</div>
						</div>
						<p>List all of the branches in your repository.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git branch &lt;branch&gt;</span>
							</div>
						</div>
						<p>Create a new branch called &lt;branch&gt;. This does not check out the new branch.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git branch -d &lt;branch&gt;</span>
							</div>
						</div>
						<p>Delete the specified branch. This is a “safe” operation in that Git prevents you from deleting the branch if it has unmerged changes.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git branch -D &lt;branch&gt;</span>
							</div>
						</div>
						<p>Force delete the specified branch, even if it has unmerged changes. This is the command to use if you want to permanently throw away all of the commits associated with a particular line of development.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git branch -m &lt;branch&gt;</span>
							</div>
						</div>
						<p>Rename the current branch to &lt;branch&gt;.</p>
					</section>
					<section id="mergfls">
						<h2>git merge</h2>
						<p>Merging is Git's way of putting a forked history back together again. The git merge command lets you take the independent lines of development created by git branch and integrate them into a single branch.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git merge &lt;branch&gt;</span>
							</div>
						</div>
						<p>Merge the specified branch into the current branch. Git will determine the merge algorithm automatically (discussed below).</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git merge --no-ff &lt;branch&gt;</span>
							</div>
						</div>
						<p>Merge the specified branch into the current branch, but always generate a merge commit (even if it was a fast-forward merge). This is useful for documenting all merges that occur in your repository.</p>
					</section>
					<section id="restfls">
						<h2>git reset</h2>
						<p>If git revert is a “safe” way to undo changes, you can think of git reset as the dangerous method. When you undo with git reset(and the commits are no longer referenced by any ref or the reflog), there is no way to retrieve the original copy—it is a permanent undo. Care must be taken when using this tool, as it’s one of the only Git commands that has the potential to lose your work.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git reset &lt;file&gt;</span>
							</div>
						</div>
						<p>Remove the specified file from the staging area, but leave the working directory unchanged. This unstages a file without overwriting any changes.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git reset</span>
							</div>
						</div>
						<p>Reset the staging area to match the most recent commit, but leave the working directory unchanged. This unstages all files without overwriting any changes, giving you the opportunity to re-build the staged snapshot from scratch.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git reset --hard</span>
							</div>
						</div>
						<p>Reset the staging area and the working directory to match the most recent commit. In addition to unstaging changes, the --hard flag tells Git to overwrite all changes in the working directory, too. Put another way: this obliterates all uncommitted changes, so make sure you really want to throw away your local developments before using it.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git reset &lt;commit&gt;</span>
							</div>
						</div>
						<p>Move the current branch tip backward to &lt;commit&gt;, reset the staging area to match, but leave the working directory alone. All changes made since &lt;commit&gt; will reside in the working directory, which lets you re-commit the project history using cleaner, more atomic snapshots.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git reset --hard &lt;commit&gt;</span>
							</div>
						</div>
						<p>Move the current branch tip backward to &lt;commit&gt; and reset both the staging area and the working directory to match. This obliterates not only the uncommitted changes, but all commits after &lt;commit&gt;, as well.</p>
					</section>
					<section id="clenfls">
						<h2>git clean</h2>
						<p>The git clean command removes untracked files from your working directory. This is really more of a convenience command, since it’s trivial to see which files are untracked with git status and remove them manually. Like an ordinary rm command, git clean is not undoable, so make sure you really want to delete the untracked files before you run it.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git clean -n</span>
							</div>
						</div>
						<p>Perform a “dry run” of git clean. This will show you which files are going to be removed without actually doing it.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git clean -f</span>
							</div>
						</div>
						<p>Remove untracked files from the current directory. The -f (force) flag is required unless the clean.requireForce configuration option is set to false (it's true by default). This will not remove untracked folders or files specified by .gitignore.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git clean -f &lt;path&gt;</span>
							</div>
						</div>
						<p>Remove untracked files, but limit the operation to the specified path.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git clean -df</span>
							</div>
						</div>
						<p>Remove untracked files and untracked directories from the current directory.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git clean -xf</span>
							</div>
						</div>
						<p>Remove untracked files from the current directory as well as any files that Git usually ignores.</p>
					</section>
					<section id="difffls">
						<h2>Difference</h2>
					</section>
					<section id="status">
						<h2>git status</h2>
						<p>The git status command displays the state of the working directory and the staging area. It lets you see which changes have been staged, which haven’t, and which files aren’t being tracked by Git. Status output does not show you any information regarding the committed project history. For this, you need to use git log.</p>
						
						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git status</span>
							</div>
						</div>
						<p>List which files are staged, unstaged, and untracked.</p>
					</section>
					<section id="logsfls">
						<h2>git log</h2>
						<p>The git log command displays committed snapshots. It lets you list the project history, filter it, and search for specific changes. While git status lets you inspect the working directory and the staging area, git log only operates on the committed history.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git log</span>
							</div>
						</div>
						<p>Display the entire commit history using the default formatting. If the output takes up more than one screen, you can use Space to scroll and q to exit.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git log -n &lt;limit&gt;</span>
							</div>
						</div>
						<p>Limit the number of commits by &lt;limit&gt;. For example, git log -n 3 will display only 3 commits.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git log --oneline</span>
							</div>
						</div>
						<p>Condense each commit to a single line. This is useful for getting a high-level overview of the project history.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git log --stat</span>
							</div>
						</div>
						<p>Along with the ordinary git log information, include which files were altered and the relative number of lines that were added or deleted from each of them.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git log -p</span>
							</div>
						</div>
						<p>Display the patch representing each commit. This shows the full diff of each commit, which is the most detailed view you can have of your project history.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git log --author="&lt;pattern&gt;</span>
							</div>
						</div>
						<p>Search for commits by a particular author. The <pattern> argument can be a plain string or a regular expression.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git log --grep="&lt;pattern&gt;</span>
							</div>
						</div>
						<p>Search for commits with a commit message that matches <pattern>, which can be a plain string or a regular expression.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git log &lt;since&gt;..&lt;until&gt;</span>
							</div>
						</div>
						<p>Show only commits that occur between &lt;since&gt; and &lt;until&gt;. Both arguments can be either a commit ID, a branch name, HEAD, or any other kind of revision reference.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git log &lt;file&gt;</span>
							</div>
						</div>
						<p>Only display commits that include the specified file. This is an easy way to see the history of a particular file.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git log --graph --decorate --oneline</span>
							</div>
						</div>
						<p>A few useful options to consider. The —graph flag that will draw a text based graph of the commits on the left hand side of the commit messages. —decorate adds the names of branches or tags of the commits that are shown. —oneline shows the commit information on a single line making it easier to browse through commits at-a-glance.</p>
					</section>
					<section id="rvrtfls">
						<h2>git revert</h2>
						<p>The git revert command undoes a committed snapshot. But, instead of removing the commit from the project history, it figures out how to undo the changes introduced by the commit and appends a new commit with the resulting content. This prevents Git from losing history, which is important for the integrity of your revision history and for reliable collaboration.</p>

						<div class="panel panel-success">
							<div class="panel-heading">EXAMPLE</div>
							<div class="panel-body">
							<span class="code-sample">&#36; git revert &lt;commit&gt;</span>
							</div>
						</div>
						<p>Generate a new commit that undoes all of the changes introduced in &lt;commit&gt;, then apply it to the current branch.</p>
					</section>
				</section>
            </div>
        </div>
    </div>
    <!-- /.container -->

    <div class="container footer">

        <hr>

        <!-- Footer -->
        <footer>
            <div class="row">
                <div class="col-lg-12">
					<p class="pull-right"><small>Reference: <a href="https://www.atlassian.com/git/tutorials" target="_blacnk">Atlassian</a></small></p>
                    <p>Copyright &copy; Sevenworks, Inc. 2016</p>
                </div>
            </div>
        </footer>

    </div>
    <!-- /.container -->

    <script src="assets/js/jquery.js"></script><!-- jQuery -->
    <script src="assets/bootstrap-sass-3.3.6/assets/javascripts/bootstrap.min.js"></script><!-- Bootstrap Core JavaScript -->
    <script src="assets/js/custom.js"></script><!-- Custom -->

</body>

</html>
